\documentclass[9pt,technote]{IEEEtran}
\usepackage{cite}

\title{SOK - A secure operating system architecture}
\author{Christopher Zell\\
        zell.christopher@fu-berlin.de}       


\begin{document}
\maketitle

  \begin{abstract}
    Abstract...
  \end{abstract}
  
  \section{Einleitung} \label{sec:intro}
    In folgendem Paper wird auf die Unterschiedlichen sicheren Betriebssysteme eingegangen ,
    deren Vorgehen erkl\"art und die Unterschiede aufgezeigt. Zum gr\"o\ss ten Teil
    wird auf den Kernel und die verschiedenen Zugriffsschutz Mechanismen eingegangen.
  \section{Zugriffsschutz Mechanismen} \label{sec:protection}
   \nocite{*}   
  
   \subsection{Multics}  
   
   Informationen werden in Segmente gespeichert und koennen geteilt werden sie beinhalten eigene Attribute 
   ueber deren Groesse sowie die Zugriffsrechte.
   
   In Multiplexed Information and Computing Service - Multics  liefer Segmentierung eine allgemeine Basis fuer den direkten Zugriff
   und das Teilen von online Informationen durch erfuellen zweier Desigin Ziele. : 1 direkt zugriff 2 Zugriffskontrolle
   
   Vorteil der direkten Adressierung ist das die Informationen nicht mehr kopiert werden muessen. Da alle instruktionen und Daten
   im System vom Prozessor adressierbar sind. D.h. duplizierung von Prozeduren und Daten is unnoetig soll heissen Abbilder von Prozessen muessen
   nicht vorher geladen werden die orginalen Prozeduren koennen direkt adressiert werden.
   
  Dies soll dem Programmierer eine attraktive reduktion der programm komplexitaet versprechen.
  
  In Multics Segemente sind Packete von Informationen welche direkt Adressiert und Kontrolliert Zugegriffen werden koennen.
  Mit jedem Segement sind Zugriffsattribute fuer jeden User der auf dieses Segment evtl. zugreifen will assoziiert.
  Diese Attribute werden von der Hardware ueberprueft. Jede Information kann direkt als Segment referenziert werden
  in anderen Systemen meist online informationen als Dateien referenziert werden. (unix, plan9 etc.)
  
  %S. 31
  In den meisten Systemen die Informationsteilung zur Verfuegung stellen sind die genannten beiden Kriterien nicht erfuellt.
  Als Beispiel wird im Paper \cite{inproc:multics} das CTSS System genannt, welches Informationen die geteilt werden sollen in Dateien vorhaelt.
  Das bedeutet das eine Kopie in den Buffer des Users kopiert werden muss damit der Benutzer darauf Zugreifen kann. (Benoetigt IO - Request)
  
  In nicht segmentierten Systemen das Benutzen von Kern Abbildern macht es sogut wie Unmoeglich den Zugriffskontrolle durchzusetzen.
  
 Die Hardware hat auf jedes Segment Zugriff mithilfe eines Segment descriptors, der die attribute beinhaltet.
 
 Multics gibt dem nutzer grosse Menge an segment descriptoren sodass Buffering der Informationen nicht mehr notwendig ist und die Informationen nicht
 ihre zugehoerigkeit verliert. Zudem heisst das ein Multics user keine Dateien benutzt sondern alle Informationen als Segmente referenziert., welche direkt vom Programm erreichbar sind.
 
 Fuer Multics users ersjcheint Speicher als eingeschlossen grosser unabhaengiger linearer Kernspeicher, jeder mit einem eigenen descriptor assoziiert. 
 Der Zugriff erfolgt durch [name, i] wobei name der symbolische Name des Segments und i ist die Wort Zahl im Linearen Speicher.
 Jeder User kann auf [name, i] referenzieren jedoch hat er nur die Zugriffsrechte die er auch vom Ersteller des Segments zugewiesen bekommen hat
 und die im Segment deskriptor eingetragen sind. Kombinationen von den folgenden Zugriffsrechten ''read'', ''write'', ''execute'' und ''append'' sind moeglich.
 
 Segmente koennen zudem in gleich grosse Teile geteilt werden sogenannten Pages. Dies wird auch in heutigen Systemen noch benutzt.
 Im Paper \cite{inproc:multics} wird auf die Vorteile drauf hingewiesen das die Allokierung durch die gleiche Groesse sehr vereinfacht wird,
 das die Pages nur im Speicher sein muessen die auch benoetigt werden das bedeutet das Segment groessen keine Einschraenkungen mehr besitzen.
 Sie weisen auch darauf hin das die Pages angefordert werden koennen die gebraucht werden und das keine anderen dann in den Speicher mit uebertragen werden muessen.
 Das ist auch eine Sache die heutzutage in aktuellen Betriebssystemen noch betrieben wird sogenanntes Paging welches mithilfe von
 verschieden Algorithmen wie FIFO (First In First Out), LRU (Last Recently used) oder anderen umgesetzt wird.
 
 Was heutzutage der TLB (translation lookaside buffer) bzw. die MMU macht (Seitennummern in Speicheradressen um mappen) hat in Multics der supervisor gemacht
 dieser transformierte den symbolischen Namen in eine passende Hardware Adresse, welche direkt vom Prozessor fuer weitere Referenzierungen benutzt wird.
 
 In der Multics Implementierung sind alle Segmente gepaged und die Page size betraegt 1024 Woerter.
 
 Prozesse sind Programme in der Ausfuehrung (definition \cite{inproc:multics}[S. 34]) Jeder Prozess in Multics besitzt ein privates Deskriptor Segement welches
 Segmentnummern in Kernspeicher adressen umwandelt und eine Private Tabelle welches die symbolischen Segmentnamen in Segmentnummern mapped. Wird
 auch als Known Segment Table KST bezeichnet. Supervisor in Multics ist im grunde wie der Kernel in heutigen Unix Systemen.
 Nicht wie in anderen Systemen arbeitet er in eigenem Speicherraum oder Prozess sondern die Supervisor Prozedur und deren Daten werden mit jedem Prozess geteilt. 
 Immer wenn ein neuer Prozess erstellt wird, wird das Deskriptor Segment mit den supervisor deskriptoren initialisiert. Dadurch muessen aber auch die Supervisor
 Segmente vor unautorisierten Zugriffen geschuetzt werden. Multics unterstuetzt den Benutzer mit einem sogenannten ring protection Mechanismen,
 welches die Segmente in dem Adressraum in einzelne Mengen mit verschiedenen Zugriffsrechten unterteilt. Dieser Mechanismus wird vom Supervisor zum
 eigenen Schutz verwendet.
 
 Name und Attribute eines Segments sind mit einem Katalog assoziiert. Im Grunde existiert eine Tabelle mit je einem Eintrag fuer ein Segment. 
 Ein Eintrag beinhaltet den Namen sowie die Segment Attribute. In Multics ist dieser Katalog als mehrere
 Segmente Implementiert und wird Verzeichnis bzw. directory genannt. Das Verzeichnis wird in einem Baum Strukturiert.
 D.h. ein Segmentname besteht aus einer Liste von einzelnen Subnamen die die Position des Eintrags im Baum reflektieren. (Subname = Entryname, liste = pathname)
 Pathname ist einzigartig in der ganzen Hierarchie und der Entryname nur im gegeben Directory.
  \subsection{Protection Rings}
    Multics wurde zuerst auf einem Honeywell 645 Computer system ausgef\"uhrt jedoch konnte die Hardware nicht viel Zugriffsmechanismen zur verf\"ugung stellen.
    Deshalb wurde eine neue Hardware entwickelt die die Zugriffsmechanismen mejhr auf Hardwareebene bringen sollte, sodass das meiste nicht mehr \"uber Software
    gepr\"uft werden muss. Das hei\ss t die sogenannten Protection rings wurden sogut wie vollst\"andig in Hardware umgesetzt. \cite{inproc:protec-rings}
    
  
    Schutz soll gew\"ahrleistet werden sodass einzelne Benutzer von einander getrennt sind und wenn gew\"unscht aber untereinander Kommunizieren k\"onnen.
    Vier Kriterien k\"onnen auf Zugriffskontrollmechanismen angewendet werden: Funktionale capability, economy, simplicity und programming generality.
    Das erste bedeutet es soll bestimmte Benutzerschtuzbed\"urfnisse tilgen, economy befasst sich dabei mit den Kosten der Umsetzung.
    Kosten beinhaltet dabei auch Komplexit\"at des Subsystems, Benutzer bel\"astigung durch benutzen dieser Zugriffsmechanismen sowie der benutze
    extra Speicher und die erh\"ohte Laufzeit. Die Kosten sollten Proportional zu den Leistungen sein.
    Simplicity bedeutet Einfachheit das heisst das die Zugriffsmechanismen so einfach wie m\"oglich sein sollen, oft
    impliziert das fehlen von Einfachheit auch das fehlen von Sicherheit. Programming generality besagt einfach das die Prozeduren so allgemein gehalten sind
    das sie ohne Wissen der internen Struktur verwendet werden k\"onnen und dinge auch ersetzt werden k\"onnen.
    Es ist schwer ein Zugriffskontrollmechanismus zu entwickeln mit der Erf\"ullung aller Kriterien.
    
    Dom\"an ist eine Menge von Zugriffsberechtigungen. Ein sehr allgemeiner Zugriffskontrollmechanismus w\"urde kein beschr\"ankung von der Anzahl an
    dom\"anen f\"ur ein Prozess machen und w\"urde keine einschr\"ankenden Beziehungen f\"ur die Zugriffsberechtigungen aufzwingen.
    Ungl\"ucklicherweise ist das Entwickeln eines solchen Mechanismus der auch die letzten drei Kriterien economy, simplicity und programming generality
    erf\"ullt ein schwieriges Forschungsthema.  In Multics wurden Anzahl von Dom\"anen f\"jur ein Prozess limitiert und es werden Beziehungen von den Zugriffsrechten innerhalb
    der Dom\"anen aufgezwungen. Das Resultat sind sogenannte protection rings. (Siehe \cite[S. 160]{inproc:protec-rings}) 
    Die Charakterisierung von Ringen als beschr\"ankte Implementierung von Dom\"anen ist das Ergebnis sp\"aterer Einsicht. 
    Als sie Entwickelt wurden, wurden Ringe als nat\"urliche verallgemeinerung der Supervisor/User Modi die Schutz in vielen Computern liefern betrachtet.
    
    Mit jedem Prozess sind eine bestimmte Anzahl von Dom\"anen assoziiert, genannt protection rings. Diese r Ringe sind mit Zahlen von $0$ bis $r - 1$ benannt.
    Die Zugriffsberechtigungen in Ring m sind so beschr\"ankt das sie eine Teilmenge von n sind, wenn gilt: $m > n$. Das bedeutet
    Ring $0$ besitzt die gr\"o\ss te Menge an Berechtigungen und $r-1$ die kleinste. Also hat ein Prozess der im Ring $0$ ausgef\"uhrt wird
    die meisten Zugriffsprivilegien und im Ring $r-1$ die wenigsten. Es existieren sogenannte brackets (engl. Klammern) f\"ur die einzelnen Berechtigungen
    wie read, write und execute. D.h. ein write bracket gibt an in welchem Bereich das write Recht angewendet werden darf. Neben den 
    Berechtigung werden noch die Ausma\ss e gespeichert und ein Flag f\"ur die jeweilige Berechtigung. Ist das Flag auf \textit{on} gesetzt 
    so wird die obere Grenze des Bereichs f\"ur die Berechtigung gespeichert, wobei der Ring r kleiner oder gleich der Grenze sein muss.
    Ist das Flag auf off gesetzt so gibt es keine Berechtigung in keinem Ring f\"ur diesem Prozess. In Multics wurden 8 Ringe als angemessen 
    angenommen und umgesetzt jedoch ist das keine Vorgabe und in anderen Systemen k\"onnen andere Anzahlen vorkommen.
    
    %gates protection rings
    Eine neue Berechtigung wurde eingef\"uhrt und zwar das \"andern der Ausf\"uhrungsdom\"an eines Prozesses.
    Dadurch das durch \"andern der Domain neue Berechtigungen dazu kommen k\"onnen ist es eine Operation die gut Kontrolliert werden muss.
    Mithilfe der Dom\"anen soll es m\"oglicjh sein das bestimmte Zugriffsberechtigungen nur an bestimmten stellen Verf\"ugbar  sind bzw. wenn bestimmte Programmteile 
    ausgef\"uhrt werden. Das hei\ss t an bestimmten Programmpositionen auch gates genannt soll es m\"oglich sein die Dom\"ane zu \"andern.
    Es werden daf\"ur gate list und gate extension eingef\"uhrt die eine neue bracket definieren in der das Programm die Ringe wechseln kann, diese
    gelten nur f\"ur das herunterwechseln der Ringe da dort mehr Rechte verf\"ugbar werden. Wechselt man ein Ring nach oben so werden es weniger Rechte deshalb
    soll das ohne beschr\"ankung m\"oglich sein. 
    
    %probleme call und return 
    %Wenn calling prozedur im gleichen ring wie caller dann kein problem
    % problem wenn calling in niedrigeren ring oder hoeherem da bei ersten mehr rechte also ueberpruefen ob 
    % caller auch rechte besitzt fuer bestimmte argumente oder ergebnisse die gelesen und geschrieben werden 
    % bei hoeherem wird returned zu niedrigem problem ist das evtl argumente nich referenziert werden koennen von aufgerufener prozedujr
    
    In Multics wird der Supervisor und die protection ring so umgesetzt das die Primitiven Operationen wie Zugriffskontrolle, I/O, Speicherverwaltung sowie
    Prozessverwaltung im Ring 0 ausgef\"uhrt werden, alles andere vom Supervisor in Ring 1.
    
    Die Hardware Umsetzung der protectiong rings die im Paper \cite{inproc:protec-rings} beschrieben wurde erm\"oglicht die drei folgenden dinge:
    \begin{itemize}
      \item Benutzer k\"onnen beliebige gesch\"utzte Sub-Systeme erstellen die von anderen genutzt werden k\"onnen
      \item Der Supervisor kann in Schichten Implementiert werden die aufgezwungen werden.
      \item Der Nutzer kann sich selbst sch\"utzen w\"arend er eigene oder andere Programme debugged.
    \end{itemize}
    
    
  \subsection{Unix}
    Unix wurde von den bekannten Informatikern Dennis Ritchie (C) und Ken Thompson (Unix, UTF8, Plan9 etc.) an den Bell Labs entwickelt.
    Es ist ein Universal-, Mehrbenutzer- und interaktives Betriebssystem. Ein gro\ss er Teil von Unix ist in C geschrieben was vorallem Multiprogramming
    und das Teilen von Code erm\"oglicht. Die wichtigste Aufgabe von UNIX ist ein Dateisystem bereitzustellen. Es gibt drei verschiedene Arten von Files:
    gew\"ohnliche Datentr\"agerdateien, Verzeichnisse, und spezielle Dateien. Anders als in Multics ist das ganze System in Dateien aufgeteilt und nicht in
    Segmente. Gew\"ohnliche Datentr\"agerdateien beinhalten die Information die der User in diese platziert. Die Struktur wird nicht vom System kontrolliert maximal
    von den zu benutzenden Programmen. Verzeichnisse liefern das Mapping zwischen den Dateinamen und den Dateien selber, somit entsteht eine Baumstruktur.
    Ein Verzeichnis ist im Grunde wie eine normale Datei nur das sie nicht von unprivilegierten Nutzern beschrieben werden kann. D.h. das System Kontrolliert den
    Inhalt der Verzeichnisse. Das System besitzt eigene Verzeichnisse und Unterverzeichnisse ein wichtiges ist \textit{root}. Alle Dateien im System k\"onnen gefunden 
    werden durch folgen eines Pfades von einer Kette von Verzeichnissen bis die Datei gefunden wurde. Der Startpunkt ist oft dabei \textit{root}.(Siehe \cite[S. 366]{inproc:unix})
    
    Das Zugriffskontrollschema ist in UNIX relativ simple. Jeder Nutzer besitzt eine eigene ID wird eine Datei erstellt vom Nutzer erh\"alt diese die ID sodass der Ersteller immer
    erfasst werden kann. Zudem gibt es 7 Bits f\"ur die Dateien die den Zugriff kontrollieren. Die ersten drei geben f\"ur den Eigent\"umer die Rechte: read, write und execute an.
    Die n\"achsten drei f\"ur alle anderen Nutzer diese Recht und das letzte Bit ist das sogenannte S-Bit. Ist dieses Bit gesetzt so wird die User ID tempor\"ar
    mit der des Datei Eigent\"umers ersetzt bzw. das Programm mit der User ID des Eigent\"umers ausgef\"uhrt.
    D.h. es werden deren Rechte benutzt f\"ur den Zeitraum der Programmausf\"uhrung. Dieses sollte erm\"oglichen das Programme
    auf Dateien zugreifen k\"onnen f\"ur die der Nutzer im normal Fall keine Rechte besitzt. (Siehe \cite[S. 367]{inproc:unix}    
    Mithilfe des S-Bits konnten jedoch einige Exploits geschrieben werden die es unautorisierten Nutzen erm\"oglichte
    die Kontrolle \"uber das System zu erlangen. 
    
    UNIX wurde laut den Autoren auch von Multics beeinflusst vorallem in dem Bereich I/O, Shell und deren Funktionalit\"at. (Siehe \cite[S. 374]{inproc:unix})
    UNIX hat sich bis heute stark durch gesetzt bzw. basieren viele heutige Systeme auf dem UNIX System.
    
   \subsection{CAP}
     Wurde entwickelt um detaillierten Speicherschutz zu gew\"ahrleisten. Die Intention ist das jedes Modul eines Programms welches auf dem CAP ausgef\"uhrt wird
     nur Zugriff auf genau die und nur die Daten besitzen soll welche sie auch wirklich f\"ur korrekte funktionalit\"at ben\"otigt.
     
     
     Capabilities werden benutzt um in CAP den Zugang zu Segment zu gew\"ahrleisten. Capabilities besitzen base und limit des Segments sowie sogenannten access status. Dieser Status
     besteht aus 5 bits, drei davon sind f\"ur den Datenzugriff also read, write und execute die anderen beiden sind f\"ur den capability Zugriff,
     d.h. read capability und write capability. Es wird zwischen data typ und capability type capabilities unterschieden, der erste Typ besitzt bits in den ersten drei bits und
     der zweite Typ in den letzten. Es existiert keine capability mit gesetzten data und capability access bits. Capabilities werden in Segmenten gespeichert die
     capability type access besitzen. Zu jeder Lebenszeit eines Prozesses sind nur die Ressourcen erreichbar die von den capabilities definiert wurden die der Prozess
     benutzen kann. Mit jedem Prozess ist ein fundamentales Segment assoziiert genannt Process Resource List (PRL). 
     Im CAP Betriebssystem existiert eine Prozesshierarchie. Als Wurzel der Hierarchie steht ein einzelner Prozess deren PRL wird auch Master Ressource List genannt.    
     Das Programm welches in diesem Prozess l\"auft ist Verantwortlich f\"ur die Erstellung und Verwaltung von Level 2 Prozessen es wird Master Coordinator genannt (MC).
     Die PRL eines Level 2 Prozesses ist ein normales Daten Segment vom MC. Es ist m\"oglich die Hierarchie zur erweitern und weitere Junior bzw. Subprozesse zu erzeugen.
     Diese ben\"otigen nur eine capability f\"ur ein Segment um dies als PRL zu nutzen.
  \subsection{MicroKernel}
    Grundidee des Micro Kernels ist das der Kernel minimiert werden soll und das alles so gut es geht ausgelagert werden soll.
    Die Vorteile dieser Herangehensweise ist das ein klares Mikro Kernel Interface die modularit\"at der Systemstruktur erh\"oht.
    Das System ist flexibler und anpassbarer. Verschiedene Strategien und Schnittstellen k\"onnen gleichzeitig im System existieren.
    
    Memory-Managment sowie Paging werden im Mikro Kernel ausserhalb platziert, nur grant, map und flash Operationen sind im Kernel enthalten. \cite[S. 238 f]{inproc:micro}
    Threads, IPC sowie das generieren von UID's (unique identifiers) werden jedoch im Kernel behalten.
    
    Ein Mikrokernel kann h\"ohere Schichten mit einem minimalen Satz von passenden Abstraktionen liefern.
    Diese sind flexible genug um beliebige Implementierungen von Betriebssystemen sowie das weite ausnutzen der Hardware zu erlauben.
    Multi-Level Sicherheitssysteme benutzen dazu noch sogenannte clans oder ein \"ahnliches Referenzmonitor Konzept.        
    Liedtke zeigt das es mit seinem L4 Mikrokernel m\"oglich ist einen performanten Mikrokernel durch Prozessorspezifische Implementierung 
    von Prozessor unabh\"angigen Abstraktionen zu erzeugen.\cite[S. 248]{inproc:micro}
%  \section{Capability systeme}
  
   
  \section{Kernel Unterschiede} \label{sec:kernel}
    Um sichere Betriebssysteme zu erstellen haben sich auch einige Wissenschaftler bzw. Informatiker mit der Verbesserung bzw. Verkleinerung
    des Kernels befasst. Sie haben diesen so strukturiert das dieser sicher ist und darauf aufbauend versucht ein sicheres Betriebssystem zu erzeugen.
  
\bibliographystyle{IEEEtran}
\bibliography{masterbib}
\end{document}
