\documentclass[9pt,technote]{IEEEtran}
%\documentclass[a4paper, 12pt]{scrartcl}
\usepackage{cite}

\title{SOK - A secure operating system architecture}
\author{Christopher Zell\\
        zell.christopher@fu-berlin.de}       


\begin{document}
\maketitle

  \begin{abstract}
    Abstract...
  \end{abstract}
  
  \section{Einleitung} \label{sec:intro}
    Das folgende Paper entstand innerhalb einer Seminararbeit IT-Sicherheit an der FU Berlin.
    Es behandelt die fr\"uhzeitlichen und neuer entwickelten Betriebssysteme und deren Ideen,
    wobei vor allem auf deren Zugriffsschutzmechanismen eingegangen wird.
    Bei dem Paper handelt es sich um ein sogenanntes Systematization of Knowledge (Sok),
    welches grunds\"atzlich f\"ur die IEEE Symposium on Security and Privacy Konferenz entwickelt wurde.
    
%    In folgendem Paper wird auf die Unterschiedlichen sicheren Betriebssysteme eingegangen ,
%    deren Vorgehen erkl\"art und die Unterschiede aufgezeigt. Zum gr\"o\ss ten Teil
%    wird auf den Kernel und die verschiedenen Zugriffsschutz Mechanismen eingegangen.
    \subsection{Motivation}
      Die Entwicklung der Betriebssysteme hat gezeigt das es verschieden und gute L\"osungen gibt um ein sicheres Betriebssystem zu entwickeln.
      Jedoch scheiterte es oft entweder an der Umsetzung oder an der Usability. In dieser Arbeit werden die Ideen f\"ur die verschiedenen Sicherheitsmechanismen  zusammengetragen.
      Falls m\"oglich wird versucht die Mechanismen zu vergleichen und zu zeigen welche sich evtl. sogar durchgesetzt haben.
   \section{Betriebssysteme}
     Seit dem die Idee existiert Mehrbenutzersysteme zu Entwickeln wurde auch dar\"uber nachgedacht wie man die einzelnen Benutzer isolieren kann.
     Aber nicht nur \"uber die Isolierung wurde nachgedacht sondern auch grundlegend wie man die Daten der jeweiligen Nutzer vor unberechtigten Zugriffen sch\"utzen kann.
     
  \section{Zugriffsschutz Mechanismen} \label{sec:protection}
  
   \subsection{Multics}  
   
   Informationen werden in Segmente gespeichert und k\"onnen geteilt werden sie beinhalten eigene Attribute 
   ueber deren Gr\"o\ss e sowie die Zugriffsrechte.
   
   In Multiplexed Information and Computing Service - Multics  liefer Segmentierung eine allgemeine Basis fuer den direkten Zugriff
   und das Teilen von online Informationen durch erfuellen zweier Desigin Ziele. : 1 direkt Zugriff 2 Zugriffskontrolle
   
   Vorteil der direkten Adressierung ist das die Informationen nicht mehr kopiert werden m\"ussen. Da alle Instruktionen und Daten
   im System vom Prozessor adressierbar sind. D.h. duplizierung von Prozeduren und Daten is unn\"otig soll heissen Abbilder von Prozessen m\"ussen
   nicht vorher geladen werden die orginalen Prozeduren k\"onnen direkt adressiert werden.
   
  Dies soll dem Programmierer eine attraktive reduktion der programm komplexitaet versprechen.
  
  In Multics Segemente sind Packete von Informationen welche direkt Adressiert und Kontrolliert Zugegriffen werden koennen.
  Mit jedem Segement sind Zugriffsattribute fuer jeden User der auf dieses Segment evtl. zugreifen will assoziiert.
  Diese Attribute werden von der Hardware ueberprueft. Jede Information kann direkt als Segment referenziert werden
  in anderen Systemen meist online informationen als Dateien referenziert werden. (unix, plan9 etc.)
  
  %S. 31
  In den meisten Systemen die Informationsteilung zur Verfuegung stellen sind die genannten beiden Kriterien nicht erfuellt.
  Als Beispiel wird im Paper \cite{inproc:multics} das CTSS System genannt, welches Informationen die geteilt werden sollen in Dateien vorhaelt.
  Das bedeutet das eine Kopie in den Buffer des Users kopiert werden muss damit der Benutzer darauf Zugreifen kann. (Benoetigt IO - Request)
  
  In nicht segmentierten Systemen das Benutzen von Kern Abbildern macht es sogut wie Unmoeglich den Zugriffskontrolle durchzusetzen.
  
 Die Hardware hat auf jedes Segment Zugriff mithilfe eines Segment descriptors, der die attribute beinhaltet.
 
 Multics gibt dem nutzer grosse Menge an segment descriptoren sodass Buffering der Informationen nicht mehr notwendig ist und die Informationen nicht
 ihre zugehoerigkeit verliert. Zudem heisst das ein Multics user keine Dateien benutzt sondern alle Informationen als Segmente referenziert., welche direkt vom Programm erreichbar sind.
 
 Fuer Multics users ersjcheint Speicher als eingeschlossen grosser unabhaengiger linearer Kernspeicher, jeder mit einem eigenen descriptor assoziiert. 
 Der Zugriff erfolgt durch [name, i] wobei name der symbolische Name des Segments und i ist die Wort Zahl im Linearen Speicher.
 Jeder User kann auf [name, i] referenzieren jedoch hat er nur die Zugriffsrechte die er auch vom Ersteller des Segments zugewiesen bekommen hat
 und die im Segment deskriptor eingetragen sind. Kombinationen von den folgenden Zugriffsrechten ''read'', ''write'', ''execute'' und ''append'' sind moeglich.
 
 Segmente koennen zudem in gleich grosse Teile geteilt werden sogenannten Pages. Dies wird auch in heutigen Systemen noch benutzt.
 Im Paper \cite{inproc:multics} wird auf die Vorteile drauf hingewiesen das die Allokierung durch die gleiche Groesse sehr vereinfacht wird,
 das die Pages nur im Speicher sein muessen die auch benoetigt werden das bedeutet das Segment groessen keine Einschraenkungen mehr besitzen.
 Sie weisen auch darauf hin das die Pages angefordert werden koennen die gebraucht werden und das keine anderen dann in den Speicher mit uebertragen werden muessen.
 Das ist auch eine Sache die heutzutage in aktuellen Betriebssystemen noch betrieben wird sogenanntes Paging welches mithilfe von
 verschieden Algorithmen wie FIFO (First In First Out), LRU (Last Recently used) oder anderen umgesetzt wird.
 
 Was heutzutage der TLB (translation lookaside buffer) bzw. die MMU macht (Seitennummern in Speicheradressen um mappen) hat in Multics der supervisor gemacht
 dieser transformierte den symbolischen Namen in eine passende Hardware Adresse, welche direkt vom Prozessor fuer weitere Referenzierungen benutzt wird.
 
 In der Multics Implementierung sind alle Segmente gepaged und die Page size betraegt 1024 Woerter.
 
 Prozesse sind Programme in der Ausfuehrung (definition \cite{inproc:multics}[S. 34]) Jeder Prozess in Multics besitzt ein privates Deskriptor Segement welches
 Segmentnummern in Kernspeicher adressen umwandelt und eine Private Tabelle welches die symbolischen Segmentnamen in Segmentnummern mapped. Wird
 auch als Known Segment Table KST bezeichnet. Supervisor in Multics ist im grunde wie der Kernel in heutigen Unix Systemen.
 Nicht wie in anderen Systemen arbeitet er in eigenem Speicherraum oder Prozess sondern die Supervisor Prozedur und deren Daten werden mit jedem Prozess geteilt. 
 Immer wenn ein neuer Prozess erstellt wird, wird das Deskriptor Segment mit den supervisor deskriptoren initialisiert. Dadurch muessen aber auch die Supervisor
 Segmente vor unautorisierten Zugriffen geschuetzt werden. Multics unterstuetzt den Benutzer mit einem sogenannten ring protection Mechanismen,
 welches die Segmente in dem Adressraum in einzelne Mengen mit verschiedenen Zugriffsrechten unterteilt. Dieser Mechanismus wird vom Supervisor zum
 eigenen Schutz verwendet.
 
 Name und Attribute eines Segments sind mit einem Katalog assoziiert. Im Grunde existiert eine Tabelle mit je einem Eintrag fuer ein Segment. 
 Ein Eintrag beinhaltet den Namen sowie die Segment Attribute. In Multics ist dieser Katalog als mehrere
 Segmente Implementiert und wird Verzeichnis bzw. directory genannt. Das Verzeichnis wird in einem Baum Strukturiert.
 D.h. ein Segmentname besteht aus einer Liste von einzelnen Subnamen die die Position des Eintrags im Baum reflektieren. (Subname = Entryname, liste = pathname)
 Pathname ist einzigartig in der ganzen Hierarchie und der Entryname nur im gegeben Directory.
  \subsection{Protection Rings}
    Multics wurde zuerst auf einem Honeywell 645 Computer system ausgef\"uhrt jedoch konnte die Hardware nicht viel Zugriffsmechanismen zur verf\"ugung stellen.
    Deshalb wurde eine neue Hardware entwickelt die die Zugriffsmechanismen mejhr auf Hardwareebene bringen sollte, sodass das meiste nicht mehr \"uber Software
    gepr\"uft werden muss. Das hei\ss t die sogenannten Protection rings wurden sogut wie vollst\"andig in Hardware umgesetzt. \cite{inproc:protec-rings}
    
  
    Schutz soll gew\"ahrleistet werden sodass einzelne Benutzer von einander getrennt sind und wenn gew\"unscht aber untereinander Kommunizieren k\"onnen.
    Vier Kriterien k\"onnen auf Zugriffskontrollmechanismen angewendet werden: Funktionale capability, economy, simplicity und programming generality.
    Das erste bedeutet es soll bestimmte Benutzerschtuzbed\"urfnisse tilgen, economy befasst sich dabei mit den Kosten der Umsetzung.
    Kosten beinhaltet dabei auch Komplexit\"at des Subsystems, Benutzer bel\"astigung durch benutzen dieser Zugriffsmechanismen sowie der benutze
    extra Speicher und die erh\"ohte Laufzeit. Die Kosten sollten Proportional zu den Leistungen sein.
    Simplicity bedeutet Einfachheit das heisst das die Zugriffsmechanismen so einfach wie m\"oglich sein sollen, oft
    impliziert das fehlen von Einfachheit auch das fehlen von Sicherheit. Programming generality besagt einfach das die Prozeduren so allgemein gehalten sind
    das sie ohne Wissen der internen Struktur verwendet werden k\"onnen und dinge auch ersetzt werden k\"onnen.
    Es ist schwer ein Zugriffskontrollmechanismus zu entwickeln mit der Erf\"ullung aller Kriterien.
    
    Dom\"an ist eine Menge von Zugriffsberechtigungen. Ein sehr allgemeiner Zugriffskontrollmechanismus w\"urde kein beschr\"ankung von der Anzahl an
    dom\"anen f\"ur ein Prozess machen und w\"urde keine einschr\"ankenden Beziehungen f\"ur die Zugriffsberechtigungen aufzwingen.
    Ungl\"ucklicherweise ist das Entwickeln eines solchen Mechanismus der auch die letzten drei Kriterien economy, simplicity und programming generality
    erf\"ullt ein schwieriges Forschungsthema.  In Multics wurden Anzahl von Dom\"anen f\"jur ein Prozess limitiert und es werden Beziehungen von den Zugriffsrechten innerhalb
    der Dom\"anen aufgezwungen. Das Resultat sind sogenannte protection rings. (Siehe \cite[S. 160]{inproc:protec-rings}) 
    Die Charakterisierung von Ringen als beschr\"ankte Implementierung von Dom\"anen ist das Ergebnis sp\"aterer Einsicht. 
    Als sie Entwickelt wurden, wurden Ringe als nat\"urliche verallgemeinerung der Supervisor/User Modi die Schutz in vielen Computern liefern betrachtet.
    
    Mit jedem Prozess sind eine bestimmte Anzahl von Dom\"anen assoziiert, genannt protection rings. Diese r Ringe sind mit Zahlen von $0$ bis $r - 1$ benannt.
    Die Zugriffsberechtigungen in Ring m sind so beschr\"ankt das sie eine Teilmenge von n sind, wenn gilt: $m > n$. Das bedeutet
    Ring $0$ besitzt die gr\"o\ss te Menge an Berechtigungen und $r-1$ die kleinste. Also hat ein Prozess der im Ring $0$ ausgef\"uhrt wird
    die meisten Zugriffsprivilegien und im Ring $r-1$ die wenigsten. Es existieren sogenannte brackets (engl. Klammern) f\"ur die einzelnen Berechtigungen
    wie read, write und execute. D.h. ein write bracket gibt an in welchem Bereich das write Recht angewendet werden darf. Neben den 
    Berechtigung werden noch die Ausma\ss e gespeichert und ein Flag f\"ur die jeweilige Berechtigung. Ist das Flag auf \textit{on} gesetzt 
    so wird die obere Grenze des Bereichs f\"ur die Berechtigung gespeichert, wobei der Ring r kleiner oder gleich der Grenze sein muss.
    Ist das Flag auf off gesetzt so gibt es keine Berechtigung in keinem Ring f\"ur diesem Prozess. In Multics wurden 8 Ringe als angemessen 
    angenommen und umgesetzt jedoch ist das keine Vorgabe und in anderen Systemen k\"onnen andere Anzahlen vorkommen.
    
    %gates protection rings
    Eine neue Berechtigung wurde eingef\"uhrt und zwar das \"andern der Ausf\"uhrungsdom\"an eines Prozesses.
    Dadurch das durch \"andern der Domain neue Berechtigungen dazu kommen k\"onnen ist es eine Operation die gut Kontrolliert werden muss.
    Mithilfe der Dom\"anen soll es m\"oglicjh sein das bestimmte Zugriffsberechtigungen nur an bestimmten stellen Verf\"ugbar  sind bzw. wenn bestimmte Programmteile 
    ausgef\"uhrt werden. Das hei\ss t an bestimmten Programmpositionen auch gates genannt soll es m\"oglich sein die Dom\"ane zu \"andern.
    Es werden daf\"ur gate list und gate extension eingef\"uhrt die eine neue bracket definieren in der das Programm die Ringe wechseln kann, diese
    gelten nur f\"ur das herunterwechseln der Ringe da dort mehr Rechte verf\"ugbar werden. Wechselt man ein Ring nach oben so werden es weniger Rechte deshalb
    soll das ohne beschr\"ankung m\"oglich sein. 
    
    %probleme call und return 
    %Wenn calling prozedur im gleichen ring wie caller dann kein problem
    % problem wenn calling in niedrigeren ring oder hoeherem da bei ersten mehr rechte also ueberpruefen ob 
    % caller auch rechte besitzt fuer bestimmte argumente oder ergebnisse die gelesen und geschrieben werden 
    % bei hoeherem wird returned zu niedrigem problem ist das evtl argumente nich referenziert werden koennen von aufgerufener prozedujr
    
    In Multics wird der Supervisor und die protection ring so umgesetzt das die Primitiven Operationen wie Zugriffskontrolle, I/O, Speicherverwaltung sowie
    Prozessverwaltung im Ring 0 ausgef\"uhrt werden, alles andere vom Supervisor in Ring 1.
    
    Die Hardware Umsetzung der protectiong rings die im Paper \cite{inproc:protec-rings} beschrieben wurde erm\"oglicht die drei folgenden dinge:
    \begin{itemize}
      \item Benutzer k\"onnen beliebige gesch\"utzte Sub-Systeme erstellen die von anderen genutzt werden k\"onnen
      \item Der Supervisor kann in Schichten Implementiert werden die aufgezwungen werden.
      \item Der Nutzer kann sich selbst sch\"utzen w\"arend er eigene oder andere Programme debugged.
    \end{itemize}
    
    
  \subsection{Unix}
    Unix wurde von den bekannten Informatikern Dennis Ritchie (C) und Ken Thompson (Unix, UTF8, Plan9 etc.) an den Bell Labs entwickelt.
    Es ist ein Universal-, Mehrbenutzer- und interaktives Betriebssystem. Ein gro\ss er Teil von Unix ist in C geschrieben was vorallem Multiprogramming
    und das Teilen von Code erm\"oglicht. Die wichtigste Aufgabe von UNIX ist ein Dateisystem bereitzustellen. Es gibt drei verschiedene Arten von Files:
    gew\"ohnliche Datentr\"agerdateien, Verzeichnisse, und spezielle Dateien. Anders als in Multics ist das ganze System in Dateien aufgeteilt und nicht in
    Segmente. Gew\"ohnliche Datentr\"agerdateien beinhalten die Information die der User in diese platziert. Die Struktur wird nicht vom System kontrolliert maximal
    von den zu benutzenden Programmen. Verzeichnisse liefern das Mapping zwischen den Dateinamen und den Dateien selber, somit entsteht eine Baumstruktur.
    Ein Verzeichnis ist im Grunde wie eine normale Datei nur das sie nicht von unprivilegierten Nutzern beschrieben werden kann. D.h. das System Kontrolliert den
    Inhalt der Verzeichnisse. Das System besitzt eigene Verzeichnisse und Unterverzeichnisse ein wichtiges ist \textit{root}. Alle Dateien im System k\"onnen gefunden 
    werden durch folgen eines Pfades von einer Kette von Verzeichnissen bis die Datei gefunden wurde. Der Startpunkt ist oft dabei \textit{root}.(Siehe \cite[S. 366]{inproc:unix})
    
    Das Zugriffskontrollschema ist in UNIX relativ simple. Jeder Nutzer besitzt eine eigene ID wird eine Datei erstellt vom Nutzer erh\"alt diese die ID sodass der Ersteller immer
    erfasst werden kann. Zudem gibt es 7 Bits f\"ur die Dateien die den Zugriff kontrollieren. Die ersten drei geben f\"ur den Eigent\"umer die Rechte: read, write und execute an.
    Die n\"achsten drei f\"ur alle anderen Nutzer diese Recht und das letzte Bit ist das sogenannte S-Bit. Ist dieses Bit gesetzt so wird die User ID tempor\"ar
    mit der des Datei Eigent\"umers ersetzt bzw. das Programm mit der User ID des Eigent\"umers ausgef\"uhrt.
    D.h. es werden deren Rechte benutzt f\"ur den Zeitraum der Programmausf\"uhrung. Dieses sollte erm\"oglichen das Programme
    auf Dateien zugreifen k\"onnen f\"ur die der Nutzer im normal Fall keine Rechte besitzt. (Siehe \cite[S. 367]{inproc:unix}    
    Mithilfe des S-Bits konnten jedoch einige Exploits geschrieben werden die es unautorisierten Nutzen erm\"oglichte
    die Kontrolle \"uber das System zu erlangen. 
    
    UNIX wurde laut den Autoren auch von Multics beeinflusst vorallem in dem Bereich I/O, Shell und deren Funktionalit\"at. (Siehe \cite[S. 374]{inproc:unix})
    UNIX hat sich bis heute stark durch gesetzt bzw. basieren viele heutige Systeme auf dem UNIX System.
    
   \subsection{CAP}
     Wurde entwickelt um detaillierten Speicherschutz zu gew\"ahrleisten. Die Intention ist das jedes Modul eines Programms welches auf dem CAP ausgef\"uhrt wird
     nur Zugriff auf genau die und nur die Daten besitzen soll welche sie auch wirklich f\"ur korrekte funktionalit\"at ben\"otigt.
     
     
     Capabilities werden benutzt um in CAP den Zugang zu Segment zu gew\"ahrleisten. Capabilities besitzen base und limit des Segments sowie sogenannten access status. Dieser Status
     besteht aus 5 bits, drei davon sind f\"ur den Datenzugriff also read, write und execute die anderen beiden sind f\"ur den capability Zugriff,
     d.h. read capability und write capability. Es wird zwischen data typ und capability type capabilities unterschieden, der erste Typ besitzt bits in den ersten drei bits und
     der zweite Typ in den letzten. Es existiert keine capability mit gesetzten data und capability access bits. Capabilities werden in Segmenten gespeichert die
     capability type access besitzen. Zu jeder Lebenszeit eines Prozesses sind nur die Ressourcen erreichbar die von den capabilities definiert wurden die der Prozess
     benutzen kann. Mit jedem Prozess ist ein fundamentales Segment assoziiert genannt Process Resource List (PRL). 
     Im CAP Betriebssystem existiert eine Prozesshierarchie. Als Wurzel der Hierarchie steht ein einzelner Prozess deren PRL wird auch Master Ressource List genannt.    
     Das Programm welches in diesem Prozess l\"auft ist Verantwortlich f\"ur die Erstellung und Verwaltung von Level 2 Prozessen es wird Master Coordinator genannt (MC).
     Die PRL eines Level 2 Prozesses ist ein normales Daten Segment vom MC. Es ist m\"oglich die Hierarchie zur erweitern und weitere Junior bzw. Subprozesse zu erzeugen.
     Diese ben\"otigen nur eine capability f\"ur ein Segment um dies als PRL zu nutzen.
  \subsection{MicroKernel}
    Grundidee des Micro Kernels ist das der Kernel minimiert werden soll und das alles so gut es geht ausgelagert werden soll.
    Die Vorteile dieser Herangehensweise ist das ein klares Mikro Kernel Interface die modularit\"at der Systemstruktur erh\"oht.
    Das System ist flexibler und anpassbarer. Verschiedene Strategien und Schnittstellen k\"onnen gleichzeitig im System existieren.
    
    Memory-Managment sowie Paging werden im Mikro Kernel ausserhalb platziert, nur grant, map und flash Operationen sind im Kernel enthalten. \cite[S. 238 f]{inproc:micro}
    Threads, IPC sowie das generieren von UID's (unique identifiers) werden jedoch im Kernel behalten.
    
    Ein Mikrokernel kann h\"ohere Schichten mit einem minimalen Satz von passenden Abstraktionen liefern.
    Diese sind flexible genug um beliebige Implementierungen von Betriebssystemen sowie das weite ausnutzen der Hardware zu erlauben.
    Multi-Level Sicherheitssysteme benutzen dazu noch sogenannte clans oder ein \"ahnliches Referenzmonitor Konzept.        
    Liedtke zeigt das es mit seinem L4 Mikrokernel m\"oglich ist einen performanten Mikrokernel durch Prozessorspezifische Implementierung 
    von Prozessor unabh\"angigen Abstraktionen zu erzeugen.\cite[S. 248]{inproc:micro}
%  \section{Capability systeme}
    \subsection{Plan 9}
        Laut den Autor von Plan 9 hatte UNIX einige Problem die zu tief lagen die dadurch nicht einfach gefixed werden konnte jedoch auch einige Ideen die \"ubernommen werden konnten
        in dem neuen System von den Bell Labs. Das war zum einen das Dateisystem um Ressourcen erreichbar zu machen und zu benennen.
    
        Die Sicht auf das System ist auf drei Prinzipien aufgebaut.
        Erstens die Ressourcen werden benannt und sind erreichbar genauso wie Dateien in einem Hierarchischem Dateisystem. Zweitens es existiert ein Standard Protokoll namens 9P um auf die 
        Ressourcen zuzugreifen. Drittens die unterschiedlichen Hierarchien die von den verschiedenen Servicen geliefert werden sind Verbunden zu einem einzelnen Privaten
        Hierarchischem Dateinamensraum. D.h. es existieren sogenannte lokale Namensr\"aume auf den nur die jeweiligen Nutzer Zugriff haben.
        Dieses Feature wird vor allem durch den eigenen Fensterserver benutzt der aus bestimmten Dateien im lokalen Namensraum Daten liest die er dann dem Nutzer anzeigt.
        
        9P ist ein Netzwerkprotokoll welches Maschinen Zugriff zu entfernten Dateien erm\"oglicht.
        Es als Menge von Transaktionen strukturiert das Anfragen von einem Client zu einem Server sendet und die Antwort zur\"uck. 9P kontrolliert Dateisystem nicht nur Dateien,
        es beinhaltet Prozeduren um Dateinamen aufzul\"osen und die Namenshierarchie vom Dateisystem des Servers zu traversieren.
        Datei Zugriff ist auf Byte und nicht auf Blockebene nicht wie bei NFS und RFS.
        
        Eine gro\ss e Plan 9 Installation hat eine Anzahl von Computer zusammen in einem Netzwerk, jeder liefert eine eigene Klasse von Anwendung. Geteilter Multiprozessorserver stellen
        Berechnungszyklen bereit andere gro\ss e Machinen stellen Speicher zur Verf\"ugung. Es existieren sogenannte Workstations welche gleichzusetzen sind mit den 
        Terminals der alten \textit{time sharing machines}. Wenn jemand das System durch ein Terminal nutzt ist es durch den Benutzer Personalisiert.
    
        Das Dateisystemmodel ist gut verstanden bei Systembauern aber auch bei allgemeinen Nutzern. D.h. Services die Datei \"ahnliches Interface bereitstellen leicht zu bauen, leicht zu verstehen
        und leicht zu benutzen. Das ist auch wirklich eines der wenigen Betriebssystem die mit an die Usability gedacht haben und es so einfach wie m\"oglich f\"ur die Nutzer zu machen.
        
        Der Dateiserver hat drei Speicherlevel, erstens memory buffer, zweitens disk und drittens Massenspeicher in einem write-once-read-many (WORM) Ger\"at. 
        Disk ist dabei der Cache f\"ur den WORM und memory ist der cache von der disk. Ein feature exisitert das es erm\"oglicht zu bestimmten Zeitpunkten ein dump vom
        Dateisystem zu erstellen. Das Dateisystem wird dabei eingefroren und alle modifizierten Bl\"ocke seitdem letztem dump werden in ein Warteschlange geschrieben
        die dann nach und nach auf dem WORM geschrieben werden. Auf die dumps hat man direkten Zugriff sodass man z.B.  alte Compiler Versionen testen kann etc.
        Zudem kann auch ein kompletter Systembackup erfolgen was aber einige Tage dauert da der Cache vom WORM erst wieder eingelesen werden muss etc.
        Die Zugriffsrechte der dump files sind die selben wie zuvor jedoch ist das Dateisystem nur read-only. D.h. Dateien k\"onnen nicht im dump geschrieben egal
        was f\"ur Zugriffsbits gesetzt sind.
        
        Die einheitliche Verbindung von Komponenten in Plan 9 macht es m\"oglich die Installation in vielen Wegen zu Konfigurieren.
        
        Authentifizierung wird f\"ur den Benutzerzugriff auf eine Ressource verwendet. Der Nutzer der die Ressource Anfragt wird Client genannt und der
        Nutzer der den Zugriff gew\"ahrt wird Server genannt. Jeder Plan 9 User hat ein assoziierten DES Authentifikationsschl\"ussel. Die Identit\"at
        des Nutzers wird verifiziert durch die M\"oglichkeit bestimmte Nachrichten \textit{challenges} zu Ver- und Entschl\"usseln.
        
        Die Authentifizierung erfolgt wie folgt: Nachdem die \textit{challenges} ausgetauscht wurden, Kontaktiert eine Partei  den Authentifizierungsserver um Berechtigungstickets Verschl\"usselt
        mit dem Schl\"ussel jeder Partei zu erstellen. Dieses beinhaltet ein neuen Konversationsschl\"usseln. Jede Partei entschl\"usselt sein eigenes Ticket und benutzt den Konversationsschl\"ussel
       um die \textit{challange} der anderen Partei zu entschl\"usseln. Plan 9 Authentifikation erm\"oglicht eine sogenannte Spricht-f\"ur Beziehung das erm\"oglicht ein Benutzer
       die Befugnis eines anderen zu haben.
       
       Plan 9 besitzt keine Super user sowie sie in UNIX existieren. Jeder Server ist verantwortlich f\"ur das aufrechterhalten der eigenen Sicherheit.
       Normalerweise erlauben des Zugriffs nur \"uber die Konsole welche mit einem Passwort gesch\"utzt ist. Wenn eine Datei Lese gesch\"utzt ist durch ein Nutzer kann
       nur dieser Nutzer Zugriff an andere weiter geben. Es existiert ein sogenannter administrativer Nutzer adm der besondere Rechte besitzt. None ist zu dem ein Benutzer
       der immer existiert und der kein Passwort besitzt. Diesem ist es immer erlaubt sich zu verbinden. None besitzt nur eingeschr\"ankte Nutzungsrechte.
       Die Idee hinter diesem Nutzer ist das selbe wie hinter dem anonymen Nutzer in FTP.
       
       \"Ahnlich wie in UNIX besitzen die Dateien sogenannte Zugriffsbits welche die read, write und execute Rechte anzeigen. Zum einen f\"ur den Besitzer der Datei, f\"ur eine bestimmte
       Gruppe und vor alle restlichen. Die Gruppen ist ein neues Feature in Plan 9 welches auch heute noch in Linux verwendet wird. Gruppen sind nichts anderes
       als ein Nutzer mit einer liste von anderen Nutzern in dieser Gruppe. F\"ur Gruppen k\"onnen sogenannte \textit{group leader} existieren diese k\"onnen die
       besagte Gruppe dann Verwalten. Normalerweise geh\"ort eine Datei zu dem Nutzer der diese erstellt hat. Der Gruppenname wird vererbt von dem Verzeichnis in dem die neue Datei liegt.
    \subsection{Exokernel}       
       Betriebssysteme definieren die Schnittstelle zwischen den Anwendungen und den Physikalischen Ressourcen.
       Ungl\"ucklicherweise kann diese Schnittstelle die Performanz sowie die Implementierung von Anwendungen einschr\"anken. \"Ublicherweise
       abstrahieren Betriebssysteme Informationen \"uber die Hardware in Prozessen, Dateien, Adressr\"aumen und IPC. Diese Abstraktionen definieren eine 
       Virtuelle Maschine in der die Anwendungen ausgef\"uhrt werden. Deren Implementierung kann nicht durch nicht vertrauensw\"urdige Anwendungen ersetzt werden.
        Das f\"uhrt zu einigen Problemen: Es verweigert Anwendungen den Vorteil von Dom\"an spezifischen Optimierungen. Es schr\"ankt zudem die flexibilit\"at von
        Anwendungserstellern ein da neue Abstraktionen nur durch sonderbare Emulationen zum System hinzugef\"ujgt werden k\"onnen.
        
        Diese Probleme wollten die Entwickler des Exokernels bek\"ampfen deren Ziel es war ein minimalistischen Kernel genannt Exokernel zu erstellen.
        Dieser Kernel vielf\"alltigt sicher die verf\"ugbaren Ressourcen. Der Rest des Systems besteht aus nicht Vertrauensw\"urdigen Anwendungen die
        z.B. IPC oder Ressource Management umsetzen. D.h. sogenannte \textit{library operating systems} arbeiten \"uber der Exokernel Schnittstelle. 
        Diese Implementieren die Schnittstelle des h\"oheren Levels. Das erm\"oglicht Anwendungen bestimmte Bibliotheken auszuw\"ahlen bzw.
        deren Implementierung direkt auf deren Notwendigkeiten anzupassen. Z.B. kann es verschiedene Arten von page-table Implementierungen
        in einem System geben. Eine Anwendung kann dann eine library mit einer bestimmten Implementierung welche am besten passt ausw\"ahlen.
        
        Um Anwendungen die Kontrolle \"uber die Hardware zu erm\"oglichen definiert der Exokernel ein Low-Level Interface.
        Der Exokernel exportiert Hardware Ressourcen was eine effiziente und einfache Implementierung erm\"oglicht.
        Mithilfe von drei Techniken wird das Exportieren sicher umgesetzt. Zum einen mit sogenannten \textit{secure bindings}, 
        dann mit \textit{visible resource revocation} und durch ein \textit{abort protocol}. 
        
        \textit{Secure binding} ist ein Schutzmechanismus der die Authentifizierung und die tats\"achliche Benutzung von einander trennt.
        Die \"Uberpr\"ufungen sind entweder in einfachen Operationen im Kernel oder Hardware ausgedr\"uckt die leicht implementiert werden k\"onnen.
        Die Authentifizierung findet nur zur Bindezeit statt, das erm\"oglicht das Verwalten los zu l\"osen vom Schutzmechanismus. Es gibt drei Basis Techniken
        um \textit{secure bindings} umzusetzen. Zum einen mit Hardware Mechanismen, Software Caching sowie mit dem Downloaden von Anwendungscode.
        Downloading des Codes kann zum erh\"ohen der Performanz benutzt werden, es besitzt zwei Vorteile. Zum einen Eliminierung von Kernel \"Ubergang (Switch)
        und die Ausf\"uhrungszeit kann eingegrenzt werden. Der wesentliche Knackpunkt ist dieser das der Code ausgef\"uhrt werden kann wenn die Anwendung nicht
        scheduled ist. Diese losl\"osung erlaubt der Ausf\"uhrung von heruntergeladenen Code in Situationen an denen ein Kontextwechsel zur Anwendung nicht m\"oglich ist.
        
        \textit{Visible resource revocation} soll es erm\"oglichen das Ressourcen die gebunden wurden wieder befreit werden von einer Anwendung bzw. deren \textit{secure binding} brechen.
        Normalerweise setzen Betriebssysteme diese revocation invisible durch. D.h. sie allozieren oder deallozieren Speicher oder Ressourcen ohne die Anwendungen zu informieren.
        Diese sichtbare resource revocation erm\"oglicht das \textit{library operating systems} darauf reagieren k\"onnen und z.B. den ben\"otigten Prozessorzustand speichern.
        Jedoch einige dinge wie Prozessor Kontextbezeichner werden sehr oft zur\"uckgeholt wo durch es besser ist die nicht sichtbare resource revocation zu nutzen.
        
        \textit{Abort protocol} erm\"oglicht es die Ressource zur\"uck zu holen indem Fall das die Anwendung auf die Anfrage der revocation nicht zufriedenstellend reagiert hat.
        Anstatt die Anwendungen die nicht in bestimmter Zeit antworten einfach zu killen werden einfach die \textit{secure bindings} aufgel\"ost und die \textit{library operating systems} bzw.
        Anwendungen informiert.
        
        Die Referenz Implementierung Aegis (Exokernel) mit dem ExOS (library operting system) gibt den Anwendungen gr\"o\ss ere flexiblit\"at 
        und Performanz als monolithische oder Mikrokernel Systeme. 
        
        
    \subsection{Spin}
       Spin ist ein Betriebssystem welches dynamisch spezialisiert werden kann, um sicher die Bed\"urfnisse von Performanz und Funktionilt\"at f\"ur
       Anwendungen anzupassen.
    
      \"Ahnlich dem Exokernel versucht Spin es zu erm\"oglichen das die Betriebssystemschnittstelle angepasst werden kann sodass die Bedingungen f\"ur Anwendungen verbessert werden k\"onnen.
      Soll hei\ss en das bei normalen Betriebssystemen die Anwendungen nur schlecht oder gar nicht laufen k\"onnen in Spin die Schnittstellen des Betriebssystem auf die Notwendigkeiten angepasst werden.
      
      Spin und seine Erweiterungen sind in der typsicheren Sprache Modula-3 geschrieben. Modula-3 besitzt folgende Kernmerkmale: Interfaces, Typsicherheit, automatisches Speichermanagement,
      Objekte, generische Interfaces, Threads und Exceptions. Durch die Typsicherheit ist gew\"ahrleistet das der Code nicht auf beliebigen Speicher zugreift, Pointer nur auf die Objekte
      des Zeigertyps verweisen etc..
      
      Das Spin Betriebssystem beruht auf vier Techniken die auf Sprach- oder Laufzeitebene implementiert sind.
      
      Die erste ist die \textit{co-location}, d.h. die Erweiterungen werden dynamisch in den Virtuellen Adressraum des Kernel verlinkt.
      \textit{Co-location} erm\"oglicht Kommunikation zwischen System und Erweiterungscode mit niedrigen Kosten.
      
      \textit{Enforced modularity}  Wie bereits erw\"ahnt sind Erweiterungen in Modula-3 geschrieben welche eine modulare
      Programmiersprache ist und f\"ur die der Compiler Schnittstellengrenzen zwischen Modulen erzwingt.
      Erweiterungen die im virtuellen Adressraum des Kernels ausgef\"uhrt werden k\"onnen auf keinen Speicher oder privilegierte Instruktionen zugreifen sofern sie nicht
      die explizite Erlaubnis durch ein Interface erhalten haben. Modularit\"at erzwungen vom Compiler erm\"oglicht es Module mit geringen Kosten zu isolieren.
      
      Die dritte Technik wird \textit{logical protection domains} genannt. Erweiterungen existieren in logischen \textit{protection domains} welche Kernel Namensr\"aume
      sind die Code und exportierte Interfaces beinhalten. Interfaces repres\"antieren Sichten auf die Systemressourcen die vom Betriebssystem gesch\"utzt sind.
      Ein im Kernel liegend dynamischer Linker l\"ost Code in seperaten logischen \textit{protection domains} zur Laufzeit auf. Erm\"oglicht \textit{cross-domain} Kommunikation 
      mit dem Overhead eines Prozeduraufrufs.
      
      Als letztes ist das \textit{dynamic call binding} zu nennen. Erweiterungen werden als Antwort auf Systemevents ausgef\"uhrt. Ein Event kann jede potentielle Aktion
      im System beschreiben, wie z.B. ein page fault. Events werden in Schnittstellen deklariert und k\"onnen abgefertigt werden mit dem Overhead eines Prozeduraufrufs.
      Siehe \cite[S. 267 f]{inproc:spin}.
      
      Das sogenannte \textit{protection model} kontrolliert die Menge an Operationen die auf die Ressourcen angewendet werden k\"onnen.
      Alle Kernel Ressourcen in Spin sind mit \textit{capabilities} referenziert. Eine \textit{capability} in Spin ist eine unf\"alschbare Referenz auf eine Ressource.
      Spin implementiert die \textit{capabilities} direkt mithilfe von Pointern, nicht wie andere Betriebssysteme die dazu Hardware oder anderes benutzen.
      Ein Pointer bzw. Zeiger kann vom Kernel zur user-level Anwendung als ver\"ausserte Referenz weitergegeben werden.
      Eine ver\"ausserte Referenz ist ein Index in der Anwendungstabelle die Typsichere Referenzen zur Kernel Datenstrukturen besitzt.
      
      Die Erweiterungen ver\"andern den Weg wie ein System ein Service zur Verf\"ugung stellt. Jede Software ist irgendwie erweiterbar, aber das sogenannte \textit{extension model}
      entscheidet wie leicht, transparent und effizient eine Erweiterung angewendet werden kann. Spin's \textit{extension model} stellt eine kontrollierte Kommunikationsm\"oglichkeit
      zwischen den Erweiterungen und dem Basis System, welches verschiedene Interaktionsarten erlaubt, zur Verf\"ugung.
      Erweiterungen in Spin sind in Events und Handler definiert. Ein Event ist eine Nachricht die eine Ver\"anderung eines Zustands im System ank\"undigt oder eine Anfrage f\"ur einen Service.
      Ein Eventhandler ist eine Prozedur die dieses Event erh\"alt und verarbeitet. Eine Erweiterung installiert einen Handler f\"ur ein Event durch explizites Registrieren mithilfe eines Zentralen 
      \textit{dispatchers}. (Siehe \cite[S. 272]{inproc:spin})
      
      Das Spin Betriebssystem demonstriert das es m\"oglich ist gute Performanz in einem erweiterbaren System, ohne die Sicherheit zu kompromittieren, zu erm\"oglichen.
    \subsection{EROS}      
        Eros ist ein \textit{capability} basierender Mikrokernel mit einem einstufigen Speichermodell. Die einstufige Speicher Persistierung ist transparent f\"ur Anwendungen.
        Speicherallokierung, Scheduling und fault Handling Politiken liegen au\ss erhalb des Kernels um verschiedene Operationsumgebungen und Anwendungsspezifische Ressourcemanagments zu erlauben.
        Eine \textit{capability} wie bereits schon erw\"ahnt ist eine unf\"alschbares Paar von Objektidentifizierer und einer Menge von erlaubten Operationen (einem Interface) an diesem Objekt.
        Lauten den Autoren ist auch ein UNIX File descriptor eine \textit{capability}. In einem \textit{capability system} h\"alt jeder Prozess \textit{capabilities} und kann diese Operationen ausf\"uhren
        welche durch die \textit{capabilities} autorisiert sind. Die Sicherheit wird dadurch gew\"ahrleistet das \textit{capabilities} f\"alschungssicher sind, Prozesse nur \textit{capabilities} durch
        Autorisierte Schnittstellen erhalten und \textit{capabilities} nur an Prozesse gegeben werden die auch autorisiert sind diese zu halten.
        
        Eine \textit{protection domain} wie bereits schon erw\"ahnt ist eine Menge von \textit{capabilities} welche von einem Subsystem zug\"anglich sind.
        
        Die Idee eines \textit{capability systems} ist die Unterteilung von Anwendungen und Betriebssystem in seperate Komponenten, .d.h. jede besitzt eigene \textit{protection domains}.
        
        EROS erstellt periodisch st\"andig Checkpoints vom System um ein Konsistentes System sicherzustellen. Bei einem System mit 256 JMB physikalischem Speicher dauert der Snapshot um die
        50ms. Was bei heutigen Systemen um einiges l\"anger dauern w\"urde.

        Die EROS Architektur ist in Kernel und Kernel Services eingeteilt zudem beinhaltet die Architektur eine Menge von Systemservices die von nicht Privilegierten Anwendungen implementiert sind.
        Der Kernel stellt eine ziemlich direkte Virtualisierung der unterliegenden Hardware via \textit{capability} gesch\"utzten Abstraktion dar.
        Daten und \textit{capabilities } werden in Seiten deren Gr\"osse bei der Hardware bestimmt ist gespeichert. \textit{Capabilities} werden zudem auch in sogenannten \textit{nodes} gespeichert,
        wobei ein \textit{node} 32 \textit{capabilities} speichern kann. Adressr\"aume werden in B\"aume aufgebaut, d.h. sie bestehen aus den zuvor genannten nodes. Deren Bl\"atter
        sind Daten- und \textit{capability}-Pages. Durch die Nutzung eines Baumes f\"ur das Adressraummapping ist es m\"oglich ein fein gradige Spezifikation von fault Handlern vorzunehmen.
        Das traversieren des Baumes ist aber ziemlich teuer weshalb einige Optimierungen notwendig sind. 
        
        Der Kernel exportiert die Prozessabstraktion in Anwendungscode via zwei Typen von \textit{capabilities}:
        \textit{Process capabilities} welche die Operationen zum Manipulieren des Prozesses liefern und \textit{entry capabilities} welche dem Halter das Aufrufen der Dienste eines Programms
        innerhalb eines bestimmten Prozess erlaubt. EROS unterscheidet nicht zwischen Prozessen und Threads. Alle Prozesse sind single-threaded. Zwei Prozesse k\"onnen evtl.
        einen Adressraum sich teilen jedoch k\"onnen beide verschiedene \textit{capabilities} besitzen. Jeder Prozess ist eine \textit{protection domain}.
        
        Jeder Ressourcen Zugriff in EROS wird via einer \textit{capability invocation} vollbracht. Wenn es bei der \textit{capability} Autorisiert ist l\"ost jeder Aufruf
        bei dem genannten Objekt ein Objekt definierte Operation die vom Aufrufer spezifiziert wurde aus. Es existiert ein einheitliches Interface was bedeutet das alle \textit{capabilities}
        die selben Argumente an nehmen, was ein Vorteil bei der Performanz bringt.
        
        Die Korrektheit des EROS Betriebssystem liegt in dem Fakt das Operationen die vom Kernel ausgef\"uhrt werden resultieren in einem korrekten Systemzustand solange
        der Initialzustand korrekt war. Die Herausforderung in der Kausalen-Ordnung ist zu Garantieren das das Wiedererlangen eines korrekten Systemzustands nachdem das System ungeplant 
        Heruntergefahren ist z.B. durch ein crash m\"oglich ist. Um das zu erreichen muss wie bereits erw\"ahnt ein konsistentes Abbild des Systems erstellt werden.
        EROS snapshot Mechanismus f\"uhrt zuvor einen Konsistenz Check durch bevor der Snapshot durchgef\"uhrt wird, anders als bei z.B. L3. Falls der Test fehlschl\"agt 
        wird das System neu gestartet ohne den derzeitigen Checkpoint zu speichern. 
        
        Die EROS IPC implementierung wurde stark von L3 und Mach 4 beeinflusst. Zudem besitzt L3 auch ein Persistierungsmechanismus der aber nicht so ausgereift ist wie der von EROS.
        
        Laut den Autoren \cite{inproc:eros} handelt es sich bei den \textit{capabilities} vom Exokernel um keine \textit{capabilities} sondern eher \"ahnlich zu dem erweiterbaren uid/gid Abstraktion,
        da sie keine Objekte benennen oder direkt Zugriff autorisieren.
        
        
        
        
   
  \section{Kernel Unterschiede} \label{sec:kernel}
    Um sichere Betriebssysteme zu erstellen haben sich auch einige Wissenschaftler bzw. Informatiker mit der Verbesserung bzw. Verkleinerung
    des Kernels befasst. Sie haben diesen so strukturiert das dieser sicher ist und darauf aufbauend versucht ein sicheres Betriebssystem zu erzeugen.
    
   \nocite{*}     
\bibliographystyle{IEEEtran}
\bibliography{masterbib}
\end{document}
